---
description: 动态规划入门3：（有最值）求状态转移方程。详将按照特定规律找出状态转移方程的方法。
---

# 凑零钱问题

## 探索规律

实际的算法问题中，写出状态转移方程是最难的，labuladong提出，可以通过如下思维方式辅助求解：

`明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case`。

## 1.题目

给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

比如说 `k = 3`，面值分别为 1，2，5，总金额 `amount = 11`。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

## 2.解析

你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。为了写出状态转移方程，在进行递归优化（备忘录法等）前，先用暴力递归的方法写出题解。

### 2.1 确定动态规划问题

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。最优子结构，就是指**当前问题可以化解为子问题求解**。

凑零钱问题为什么符合最优子结构呢？比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = (11-1)` 的最少硬币数（子问题），你只需要把子问题的答案加1（再选一枚面值为 1 的硬币）就是原问题的答案。这里只选择了1，而最后一枚硬币选择的是2或者5也是有可能的，所以需要循环“状态转移数组”（coins=\[1,2,5\]）得到每个上级子问题，然后每个子问题依次向上递归。

### 2.2 确定状态转移方程

既然知道了这是个动态规划问题，就要思考**如何列出正确的状态转移方程**？

**先确定「状态」**，也就**是原问题和子问题中变化的变量**。由于硬币数量无限，所以唯一的状态就是目标金额 `amount`。（上台阶问题的状态是剩下的台阶数；路径问题的状态是走到当前的二维矩阵）。**“状态”是用来传递的，是每次递归的参数。**

**然后确定 `dp` 函数的定义**：当前的目标金额是 `n`，至少需要 `dp(n)` 个硬币凑出该金额。

**然后确定「选择」并择优**，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 `coins` 中选择一个硬币，然后目标金额就会减少。（上台阶问题的选择是上一级还是两级；路径问题的选择是向右走还是向下走）

```javascript
function coinChange(coins=[], amount=11){
    function dp(n){
        //做选择，选择需要硬币最少的那个结果
        for(let coin in coins){
            res = Math.min(res, 1 + dp(n - coin))
        }
        return res
    }
    //我们要求的问题是 dp(amount)
    return dp(amount)
}
```

说一下和前面台阶问题、路径问题的区别。上面提到了“状态”和“选择”两方面的不同。在“选择”方面，台阶和路径问题是一类简单问题，因为他们的每次的选择只有两种，因此可以直接用f\(status-1\)+f\(status-2\)这种递归方程完成题解；而找零问题，每次的选择有多种，由给出的硬币面值数组（coins）决定，因此要用for循环，每个循环中进行一次递归。与此同时，“找零问题”不仅要做递归，而且还要在每次取钱时找出最优解，因此每次for循环都会用min求出一个最小值就可以了（这一步中阶梯和路径问题是求和）。

这里的循环嵌套递归，和回溯问题的解题方式非常相似，但回溯问题目标一般是枚举所有状态；动态规划是有目标状态，目标是枚举可达目标状态的方案。或者说，回溯问题一般是从第一个数据开始往下走，找合适的位置；而动态规划是确定终点目标，然后往回找。虽目标不同，但两种问题可以融合成一种问题来思考，就是枚举。有些人觉得这是用回溯的思想来解答的这道题也没毛病。

就这样，用枚举的思想（暴力破解）来解这道题，自然而然就把状态转移矩阵写出来了。还有个难点就是在哪求最小值，写在正确的位置就ok了。

### **2.3 写出最终代码**

**明确 base case**，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1。写出最终代码：

```javascript
function coinChange(coins, amount){
    function dp(n){
        //basecase
        if(n===0){return 0}
        if(n<0){return -1}
        let res=Infinity
        for(let coin of coins){
            //求解子问题
            let subproblem=dp(n-coin)
            //子问题无解,跳过
            if(subproblem===-1){ continue }
            //加1是次数
            res = Math.min(res, 1 + subproblem)
        }
        if(res===Infinity){return -1}
        return res 
    }
    return dp(amount)
}
//测试代码
let coins=[1,2,5]
coinChange(coins,11)
```

以上算法就是暴力解法了，其中的状态转移方程是：

```javascript
f(n)=min(f(n-coin)+1)  (coin∈coins)
在这道题中就是：f(n)=min(f(n-1),f(n-2),f(n-5))+1
```

加上base case，写成数学形式就是状态转移方程：

![](../../.gitbook/assets/tu-pian-%20%284%29.png)

**时间复杂度分析：子问题总数 \* 每个子问题的时间**。

下面就来消除一下**重叠子问题**，也就是用【备忘录法】或者【DP table】法了。

### **2.3 优化**

### **2.4 其他**

解决这个问题还可以用贪心算法，因为可以从大数开始扣钱，大额钱扣的越多，小额钱用的越少。

用贪心算法解题有一定危险性，因为得到的结果不一定是最优解。

例如`acount=18,coins=[10,9,1]`，那么不是`"一个10 + 8个1"`最少，而是`"两个9"`最少。当然，在零钱里面没有面额为9的面值，而且大额面值一般都会超过下一级面值的2倍大，例如10元下面是5元，因此贪心算法解决实际中的零钱问题不会产生这种风险。而其他类型的数据就不能这样保证了。





#### 参考文献：

{% embed url="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie\#yi-fei-bo-na-qi-shu-lie" %}







