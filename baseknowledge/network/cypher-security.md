---
description: >-
  从以前笔记中粘贴过来的，格式不太优美，有空整理。参考文献：http://47.98.159.95/my_blog/browser-security/001.html#什么是-xss-攻击？参考文献：https://juejin.im/post/5cd6ad7a51882568d3670a8e
---

# 网络安全

## 前端有哪些攻击方式?

### Xss攻击

* 视频理解：[https://www.bilibili.com/video/BV1DW411U7XE?from=search&seid=6876487777474602796](https://www.bilibili.com/video/BV1DW411U7XE?from=search&seid=6876487777474602796)
* 什么是XSS攻击？
  * XSS：cross site script 跨站脚本攻击。是一种代码注入攻击。当目标站点被用户访问，在渲染页面的过程中，出现了没有预期到的脚本指令。
  * 攻击者要做的就是就是向有XSS漏洞的网站输入自己的脚本，在用户访问页面的时候，能执行自己插入的脚本。这个插入的脚本往往能获得用户的个人信息。
  * XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。
* 有什么危害？
  * 挂马，盗取用户cookie，钓鱼攻击，恶意篡改嫁祸，刷广告刷流量等。
* XSS攻击有几种类型？
  * 根据攻击的来源，XSS攻击可以分为存储型\(持久性\)、反射型\(非持久型\)和DOM型三种。
  * 反射型
    * 攻击者注入的数据直接反映在服务端的响应中
    * 在链接中植入xss代码发送get请求，服务器做出一次性回应。
    * 一般是黑客发送邮件或者聊天发送地址，用户点击后达到攻击目的。
  * 存储型
    * 提交的代码会存到服务器。
    * 场景：留言板，黑客将xss代码插入到留言板中，其他用户查看留言板的时候，网页都会去请求一次留言板的数据，这时就会执行一次这个xss代码。
  * 基于DOM的攻击
    * 用户能够通过交互修改浏览器页面中的DOM并显示在浏览器上时，就有可能产生这种漏洞，从效果上来说它也是反射型XSS。
    * 触发条件为浏览器DOM解析。易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象）
    * 场景：黑客猜到客户端操作DOM的代码，在可能运行dom的地方插入代码。
* 存在原因：
  * 对有用户提交输入的地方或者url参数没有做充足的过滤。过于信任客户端提交的数据。
    * 用户输入
    * url参数
    * post请求参数
    * ajax
* 如何防范XSS攻击？
  * 对用户输入和url参数进行过滤。
    * 将半角字符转换成全角字符
    * 黑名单策略，列出不能出现的脚本清单
    * 限制输入长度
    * 限制输入内容，例如不能输入特殊字符
  * 对输出进行编码，让代码无法执行
    * 转义 例如&lt; : &lt &gt;: &gt \:\\ /:\/
  * 服务器端将cookie设置为http-only
    * 这样使得前端js无法读取cookie
  * 编程语言的防御代码（第三方防御工具）
    * 例如nodejs 用js-xss库 java用xss-filter库 springboot xss过滤器等，一些编程语言或框架有内置的放xss的策略。

### CSRF

* 什么是CSRF攻击？
  * 跨站请求伪造 cross site request forgery
  * 用户在网站中保留了登陆凭证cookie，访问恶意网站，恶意网站向原网站发请求，攻击者盗用原网站的cookie，以用户的名义向服务端发送恶意请求
  * 跨站请求的方法：图片URL、超链接、CORS、Form等等
* 场景：以用户的名义购买东西或转账等。
  * 场景一：在一个有CSRF漏洞的支付网站上没有退出自己的账号，黑客发送一个网站，用户点开后是一个图片（img又不能过滤数据），图片的src中嵌入了恶意代码，是转账请求代码。（前提是get请求）
  * 场景二：在一个有CSRF漏洞的支付网站上没有退出自己的账号，黑客发送一个网站，用户点开后有一个iframe，嵌入了一个隐藏form表单，当用户访问网站的时候，提交这个form表单。（这时候post请求也可以发送了）
* 如何产生的？
  * 本质原因：web服务器验证不够，只验证了用户的session（cookie），不能保障某次请求一定是用户触发的。而且黑客可以完全伪造用户信息。
* 如何防范CSRF攻击？
  * 1.尽量使用POST，而不是GET
  * 2.加入验证码，验证是用户行为，而不是黑客行为
  * 3.验证Refer，HTTP请求头部有一个refer字段，能够提供这个http请求网站来源地址（但某些浏览器上可以篡改refer值）
  * 4.常用-Anti CSRF Token-让黑客无法完全伪造用户请求信息
    * 在form表单或html头信息中传递token（服务器端生成token，然后把token放入到session中）
    * 所有的用户请求都携带一个CSRF攻击者无法获取到的Token。
    * 跟验证码类似，只是用户无感知。
    * - 服务端给用户生成一个token，加密后传递给用户
    * - 用户在提交请求时，需要携带这个token
    * - 服务端验证token是否正确

### 点击劫持

* 在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。

